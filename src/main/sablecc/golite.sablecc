Package golite ;

Helpers

    //CHARACTERS

    //Some Symbols
    underscore = '_';
    slash = '/';
    backslash = '\';
    star = '*';
    dot = '.';


    //Universal Character Set
    ch_set = [0 .. 0xFFFF];

    tab = 9;
    newln = 10 ;
    carrret = 13;

    endln = carrret newln | carrret | newln;
    not_endln = [ch_set - [carrret + newln]];

    // Alphabets
    alpha = ['A' .. 'Z'] | ['a' .. 'z'];

    //Numeric Characters

    zero = '0';
    num_ch = ['0' .. '9'] ;
    oct_num_ch = ['0' .. '7'];

    nozero = [num_ch - '0'];
    hex_num_ch = num_ch | alpha;

    sp = ' ';
    single_quot = ''';
    double_quot = '"';
    back_q = '`';

    // Escape Sequence
    escapes = '\' ('\'| 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' );
    escape_squote = '\' ''';
    escape_dquote = '\"';

    no_carr_nl = [ch_set - [carrret + newln]] ;
    no_carr_nl_sl = [no_carr_nl - backslash];

    alpha_hyphen = alpha | underscore;
    alpha_numch = alpha_hyphen | num_ch ;



Tokens

    star = star;
    slash = slash;

    //Blanks & WhiteSpace
    endln = carrret newln | carrret | newln;
    wht_sp = (sp | endln | tab) +;

    kw_break = 'break';
    kw_case = 'case';
    kw_chan = 'chan';
    kw_const = 'const';
    kw_continue = 'continue';
    kw_default = 'default';
    kw_defer = 'defer';
    kw_else = 'else';
    kw_fallthrough = 'fallthrough';
    kw_for = 'for';
    kw_func = 'func';
    kw_go = 'go';
    kw_goto = 'goto';
    kw_if = 'if';
    kw_import = 'import';
    kw_interface = 'interface';
    kw_map = 'map';
    kw_package = 'package';
    kw_range = 'range';
    kw_return = 'return';
    kw_select = 'select';
    kw_struct = 'struct';
    kw_switch = 'switch';
    kw_type = 'type';
    kw_var = 'var';

    print = 'print';
    println = 'println';
    append = 'append';

    // Data Types
    int = 'int';
    float64 = 'float64';
    bool = 'bool';
    rune = 'rune';
    string = 'string';

    //Operators

    plus = '+';
    minus = '-';


    mod = '%';
    ampr = '&';
    pipe = '|';
    crt = '^';
    lshift = '<<';
    rshift = '>>';
    ampr_crt = '&^';
    plus_eql = '+=';
    minus_eql = '-=';
    star_eql = '*=';
    slash_eql = '/=';
    mod_eql = '%=';
    ampr_eql = '&=';
    pipe_eql = '|=';
    crt_eql = '^=';
    lshift_eql = '<<=';
    rshift_eql = '>>=';
    ampr_crt_eql = '&^=';
    dbl_ampr = '&&';
    dbl_pipe = '||';
    inp = '<-';
    dbl_plus = '++';
    dbl_minus = '--';
    dbl_eql = '==';
    less_than = '<';
    greatr_than = '>';
    eql = '=';
    not = '!';
    not_eql = '!=';
    less_than_eql = '<=';
    greatr_than_eql = '>=';
    col_eql = ':=';
    ellipsis = '...';

    lf_paren = '(';
    lf_sq_paren = '[';
    lf_brace = '{';
    comma = ',';
    dot = dot;

    rht_paren = ')';
    rht_sq_paren = ']';
    rht_brace = '}';

    semi = ';';
    coln = ':';

    underscore = underscore;

    //COMMENTS

    comment = '//' not_endln * | '/*' ([ch_set - star] | star [ch_set - slash])* '*/';

    // IDENTIFIER
    //idenf = alpha alpha_num* | underscore alpha_num+ ;

    idenf = alpha alpha_numch* | underscore alpha_numch+;

    // DataTypes

    // Int
    int_dtype = zero | num_ch num_ch*;
    oct_dtype = zero oct_num_ch+;
    hex_dtype = zero ['x' + 'X'] hex_num_ch+;

    // Float
    float_dtype = num_ch* dot num_ch* | dot num_ch+;

    /* String literals */

    // "hello\n" // Interpreted string, \n is transformed into newline
    interpreted_string_dtype = double_quot ([no_carr_nl_sl - single_quot] | escape_dquote| escapes)* double_quot;

    // `hello\n` // Raw string, \n appears as a `\` followed by `n`
    raw_string_dtype = back_q [ch_set - back_q]* back_q;

    rune_dtype = single_quot ([no_carr_nl_sl - single_quot] | escape_squote| escapes) single_quot;


Ignored Tokens
    comment,
    wht_sp;

Productions

    // Program
    prog = pack_dec dec* ;

    //Declarations
    dec = {var_decl} var_decl | {type_decl} type_decl | {func_decl} func_decl ;

    //Package declaration
    pack_dec = kw_package idenf semi;

    //Variable declarations
    var_decl  =   {single} kw_var spec_var semi            
              | {distributed} kw_var lf_paren spec_var_stmt* rht_paren semi ;

    spec_var_stmt  = spec_var semi ;

    spec_var  = {type} idenf_opt_list type            
        | {expr} idenf_opt eql expr_list            
        | {typeandexpr} idenf_opt_list type eql expr_list;

    //Type declarations
    type_decl   =    {single} kw_type type_spec semi            
        	   | {distributed} kw_type lf_paren type_spec_stmt* rht_paren semi ;

    type_spec_stmt = type_spec semi ;

    type_spec = idenf_opt type_basic ;

    //Function declarations

    func_decl = {return} kw_func idenf lf_paren arg_list rht_paren type_basic block semi            
          | {no_return} kw_func idenf lf_paren arg_list rht_paren block semi;
   
    block  = lf_brace stmt* rht_brace;

   // For testing until real statements are done
    stmt = {empty} raw_string_dtype semi | interpreted_string_dtype  semi;
   
   
    // EXPRESSIONS
    expr = expr_binary_one;

    expr_int = {expr_int_dec} int_dtype | {expr_int_octal} oct_dtype | {expr_int_hex} hex_dtype;
    expr_string = {expr_string_intr} interpreted_string_dtype | {expr_string_raw} raw_string_dtype;

    expr_atom = {expr_ident} idenf
            | {expr_int} expr_int
            | {expr_float} float_dtype
            | {expr_rune} rune_dtype
            | {expr_string} expr_string
            | {expr_paren} lf_paren expr rht_paren;

    // Arguments are comma separated
   // arg_list = {single} expr | {multiple} expr comma arg_list;
    // An argument list is between () and can be empty
    args_list = lf_paren arg_list? rht_paren;

    expr_primary = {expr_atom} expr_atom
            | {expr_select} expr_primary dot idenf
            | {expr_index} expr_primary lf_sq_paren expr rht_sq_paren
            | {expr_call} expr_primary args_list
            | {expr_cast} type_basic lf_paren expr rht_paren
            | {expr_append} append lf_paren [arg1]:expr comma [arg2]:expr rht_paren;

    expr_unary = {expr_primary} expr_primary
            | {expr_logic_not} not expr_unary
            | {expr_reaffirm} plus expr_unary
            | {expr_negate} minus expr_unary
            | {expr_bit_not} crt expr_unary;

    expr_binary_five = {expr_unary} expr_unary
            | {expr_mul} expr_binary_five star expr_unary
            | {expr_div} expr_binary_five slash expr_unary
            | {expr_rem} expr_binary_five mod expr_unary
            | {expr_lshift} expr_binary_five lshift expr_unary
            | {expr_rshift} expr_binary_five rshift expr_unary
            | {expr_and} expr_binary_five ampr expr_unary
            | {expr_and_not} expr_binary_five ampr_crt expr_unary;

    expr_binary_four = {expr_binary_five} expr_binary_five
            | {expr_add} expr_binary_four plus expr_binary_five
            | {expr_sub} expr_binary_four minus expr_binary_five
            | {expr_bit_or} expr_binary_four pipe expr_binary_five
            | {expr_bit_xor} expr_binary_four crt expr_binary_five;

    expr_binary_three = {expr_binary_four} expr_binary_four
            | {expr_eq} expr_binary_three dbl_eql expr_binary_four
            | {expr_neq} expr_binary_three not_eql expr_binary_four
            | {expr_less} expr_binary_three less_than expr_binary_four
            | {expr_less_eq} expr_binary_three less_than_eql expr_binary_four
            | {expr_great} expr_binary_three greatr_than expr_binary_four
            | {expr_great_eq} expr_binary_three greatr_than_eql expr_binary_four;

    expr_binary_two = {expr_binary_three} expr_binary_three
            | {expr_logic_and} expr_binary_two dbl_ampr expr_binary_three;

    expr_binary_one = {expr_binary_two} expr_binary_two
                | {expr_logic_or} expr_binary_one dbl_pipe expr_binary_two;


       // TYPES
    type = {type_basic} type_basic | {type_slice} type_slice | {type_array} type_array | {type_struct} type_struct;

    type_basic = {type_int} int | {type_float64} float64 | {type_bool} bool | {type_rune} rune | {type_string} string;

    type_slice = lf_sq_paren rht_sq_paren type;

    type_array = lf_sq_paren expr_int rht_sq_paren type;

    idenf_list = {single} idenf | {multiple} idenf comma idenf_list;
    field = idenf_list type semi;

    type_struct = kw_struct lf_brace field* rht_brace;

    idenf_opt_list  = {singleopt} idenf_opt
                     | {multipleopt} idenf_opt comma idenf_opt_list ;

    idenf_opt = {empty} underscore
           | {idenf} idenf ;
     
    expr_list  =  {empty}
       | {expr_list} expr_comma* expr ;

    expr_comma = expr comma;

    arg_list   = {empty} | {arg_list} args_start* args_type_spec;

    args_start   = args_type_spec comma;
    args_type_spec  = idenf_list type_spec;
