# Milestone 3

## Motivation

We have chosen to implement Milestone 4 using low-level code, specifically, LLVM-IR. More specifically, 
we plan to first convert Golite to a simpler IR and thereby convert this IR to a LLVM IR representation,
specifically using the LLVM C API. We plan to use LLVM because as a backend, as it's used by several popular
languages like Rust, Swift, C, C++, D, etc. Not just LLVM offers some optimization by default, but with
LLVM, it's also possible to create new optimization passes with minimal code changes to existing code.
Finally, LLVM IR is comparitively easy to work with and due to its popularity is well documented
and standardized meaning that if we get stuck somewhere, we have the documentation to look at and resolve 
the issue.

It has some disadvantages in that it is comparatively more difficult to implement than higher level languages
like C/C++ but we wanted to take on this challenging task and in the process learn more about LLVM IR 
implementation. It also supports a much smaller set of languages compared to GCC (IR) but we are not 
concerned with the extendibility for other languages, so we can choose to ignore it.

## Implementation

After type-checking, we run the `SemanticData` produced by our type-checker through our `IrConverter`.
The `IrConverter` visits AST nodes and converts them to our custom node types (found in `golite.ir.node`)
to facilitate conversion to LLVM-IR. The `Program` class contains all the relevant information required
for code generation: the package name, global variables, and functions (through which enclosed statements
can be accessed). The converter has a `Program` field that contains all of this information in the custom
node types that are produced during conversion. The conversion allows for complicated statements to be split
up into multiple simple statements //insert example here! //mention the parts left to be done

The `CodeGenerator` takes in the `Program` generated by the conversion phase and visits all converted nodes 
for translation into LLVM IR, using the LLVM C API. //Mention which sections have been done

## Test Programs

#### MultiAssignSwap.go :
It's a good edge case for Code Generation. a, b = b, a should swap variables, which won't work unless you 
codegenerate intermediate variables for the values. 
#### switch_codegen.go: 
Checks if the generated code is able to handle the comparison condition in a case conditional. Many languages 
like C don't support these kind of Case conditions by default, so it is an interesting case.
#### switch_codegen_booleans.go:
This again checks if the generated code is able to handle two booleans in a case conditional. Many languages
like C don't support these kind of case conditions by default, so it is an interesting case as well.
#### array_default.go :
It's a good test case to check if an array is initialized during the codegen by default. We used a multidimentional 
float array to check this.
#### scope_var.go: 
This program is to ensure that the scopes are handled currectly by the codegen. The value of the variable outside
the function scope should be replaced by the newly declared in-scope value.
