# Milestone 3

## Motivation

We have chosen to implement Milestone 4 using low-level code, specifically, LLVM-IR. More specifically, 
we plan to first convert Golite to a simpler IR and thereby convert this IR to a LLVM IR representation,
specifically using the LLVM C API. We plan to use LLVM because as a backend, as it's used by several popular
languages like Rust, Swift, C, C++, D, etc. Not just LLVM offers some optimization by default, but with
LLVM, it's also possible to create new optimization passes with minimal code changes to existing code.
Finally, LLVM IR is comparitively easy to work with and due to its popularity is well documented
and standardized meaning that if we get stuck somewhere, we have the documentation to look at and resolve 
the issue.

It has some disadvantages in that it is comparatively more difficult to implement than higher level languages
like C/C++ but we wanted to take on this challenging task and in the process learn more about LLVM IR 
implementation. It also supports a much smaller set of languages compared to GCC (IR) but we are not 
concerned with the extendibility for other languages, so we can choose to ignore it.

## Implementation

After type-checking, we run the `SemanticData` produced by our type-checker through our `IrConverter`.
The `IrConverter` visits AST nodes and converts them to our custom node types (found in `golite.ir.node`)
to facilitate conversion to LLVM-IR. The `Program` class contains all the relevant information required
for code generation: the package name, global variables, and functions (through which enclosed statements
can be accessed). The converter has a `Program` field that contains all of this information in the custom
node types that are produced during conversion. The conversion allows for complicated statements to be 
split up into multiple simple statements //insert example here! 
Conversion needs to be implemented for perator-assignment, increment and decrement statements. All other 
conversions have been implemented.

Here is a simple Golite program:

    package main

    type Person struct {
        name string
        age int
    }
    
    var arr1 [16]Person
    var arr2 [16]Person
    
    func main() {
        println(arr1 != arr2)
    }

It is converted to the follow custom IR:

    package main
    
    var arr1 [16]struct {name string; age int}
    var arr2 [16]struct {name string; age int}
    
    func main() {
        var arrLeft [16]struct {name string; age int}
        assign(arrLeft, arr1)
        var arrRight [16]struct {name string; age int}
        assign(arrRight, arr2)
        var arrEq bool
        assign(arrEq, true)
        var arrIdx int
        assign(arrIdx, 0)
    
    startLoop:
        jump(endLoop, ((arrIdx >= 16) || !arrEq))
        var structLeft struct {name string; age int}
        assign(structLeft, arrLeft[arrIdx])
        var structRight struct {name string; age int}
        assign(structRight, arrRight[arrIdx])
        var structEq bool
        assign(structEq, true)
        jump(structNeq, !(structLeft.name ==$ structRight.name))
        jump(structNeq, !(structLeft.age == structRight.age))
        jump(endStructEq, true)
    
    structNeq:
        assign(structEq, false)
    
    endStructEq:
        assign(arrEq, structEq)
        assign(arrIdx, (arrIdx + 1))
        jump(startLoop, true)
    
    endLoop:
        printBool(!arrEq)
        printString("\a")
        return
    }
    
    init {
        memset(arr1, 0)
        memset(arr2, 0)
        return
    }

The `CodeGenerator` takes in the `Program` generated by the conversion phase and uses LLVM C API calls to 
create the object structure representing the IR. The remaining implementation work is for unary and binary 
expressions, as well as most types of statements.

## Test Programs

#### MultiAssignSwap.go :
It's a good edge case for Code Generation. a, b = b, a should swap variables, which won't work unless you 
codegenerate intermediate variables for the values. 
#### switch_codegen.go: 
Checks if the generated code is able to handle the comparison condition in a case conditional. Many languages 
like C don't support these kind of Case conditions by default, so it is an interesting case.
#### switch_codegen_booleans.go:
This again checks if the generated code is able to handle two booleans in a case conditional. Many languages
like C don't support these kind of case conditions by default, so it is an interesting case as well.
#### array_default.go :
It's a good test case to check if an array is initialized during the codegen by default. We used a multidimentional 
float array to check this.
#### scope_var.go: 
This program is to ensure that the scopes are handled currectly by the codegen. The value of the variable outside
the function scope should be replaced by the newly declared in-scope value.
